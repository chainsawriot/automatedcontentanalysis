[
["index.html", "Automated Content Analysis Chapter 1 Prerequisites", " Automated Content Analysis Chung-hong Chan 2020-02-28 Chapter 1 Prerequisites We will use these R packages in this book. install.packages(c(&quot;quanteda&quot;, &quot;rio&quot;, &quot;stm&quot;, &quot;tidyverse&quot;, &quot;text2vec&quot;)) The data used in this book is available in this book’s github repo: https://github.com/chainsawriot/automatedcontentanalysis/tree/master/data The website is (and will always be) free to use, and is licensed under the Creative Commons Attribution-NonCommericial-NoDervis 3.0 License (CC BY-NC-ND 3.0). If you’d like to give back please make donation to Hong Kong Free Press or Stand News. Both are non-profit news websites based in Hong Kong. This book is written in RMarkdown with bookdown. Dr. Chung-hong Chan, Mannheim, Germany, 2020. "],
["intro.html", "Chapter 2 Introduction", " Chapter 2 Introduction When I was a high-school student, biology was my favourite subject. Of course, I need to have the biology textbook to study and my school had assigned me to buy one. My older brother are 7 years older than me and he had the same textbook but an outdated edition. Hence, I didn’t need to buy one, I just used his book. My classmates were using the newer edition, but I enjoyed reading the old edition from my brother. That book had over 1,000 pages and was completely in black and white. Students and teachers alike spotted me reading that book almost all the time at the corner of the spectator stand. At the time of my graduation, that 1,000-page book was broken into multiple ‘volumes’, due to my very frequent reading. Why do I need to bring this little irrelevant story up? Francis Crick, James Watson and the oft-ignored female post-graduate student Rosalind Franklin discovered the double-helix structure of DNA in 1953. By the time I was reading the biology textbook printed in the early 90s, it was almost 40 years ago. The biology textbook of the period had an introduction to the double helix structure of DNA, as you can imagine, in a boring way. I would say the discovery of the double helix structure is probably one of the most important discovery in science, the textbook of the period did not describe it as a “hype”. Instead, it was described as if it was as boring as counting sheep. When something was written in the textbook, that something is instantly became uncool. But still, why do I need to bring this little irrelevant story up? Some would dispute this, but the world first automated content analysis system is probably the General Inquirer system. The original paper about the system was published in 1962 by the late Philip J. Stone and his colleagues at the Harvard Laboratory of Social Relations. The General Inquirer (GI) uses a method—that is called “dictionary-based method” now—to quantify the characteristics of a piece of text. At the time of writing, it is 2020 now. The world first automated content analysis was 58 years old. If there is still an innovation factor of using a 58-year old technology and hype about it, it is actually absurd. Although mew dictionaries are developed almost every month, many communication researchers—myself included—are doing automated content analysis the way very similar to Philip J. Stone and Co. did back in 1962. The discouse about automated content analysis should be very similar to way I read about the double helix structure when I was a high-school student in the mid 90s: it should be boring and uncool. The motto of this book is simple: Making automated content analysis uncool again. I must admit that I stole this motto from another project: The folks at fast.ai have used the motto “Making neural nets uncool again” since the website’s inception. The founders of the MOOC site feel that the hype around deep learning or artificial intelligence is very unhealthy. They says in their mission statement that being cool is about being exclusive. They want to make deep learning as accessible as possible —including those using uncool operating systems like Windows and with uncool backgrounds (e.g. those did not go to Stanford). As a person using an uncool text editor —emacs, a now 44-year-old technology— to write this book, I agree with their vision. I want to make automated content analysis as accessible as possible so that there is no more hype around it. Everyone can do it and everyone can then do it correctly. As everyone, cool and uncool people included, can do automated content analysis by reading this open access book, we should ask more important questions such as: Are we doing automated content analysis in a way that has adequate validity and reliability? I hope you will enjoy reading this book. "],
["the-whole-game.html", "Chapter 3 The whole game 3.1 Analysing Trump’s tweets 3.2 An express summary of tidyverse 3.3 Creating ground truth data 3.4 Automated sentiment analysis: AFINN 3.5 Comparing tweets from Android and iPhone 3.6 Zusammenfassung", " Chapter 3 The whole game Figure 3.1: Screenshot of the first level of Megaman X (Capcom, 1993) 3.1 Analysing Trump’s tweets We are going to use an example to illustrate the whole process of a typical automated content analysis scenario. This is called the “Play the Whole Game” approach by Perkins (2010).1 In this example, we start with a simple research question or hypothesis. Let’s say I want to reproduce a very famous analysis of Donald Trump’s tweets. This example is very well-known in the data science world, probably because David Robinsom (one of the authors of the tidytext package) used this example to demonstrate the power of his package (and made him on the television). In David Robinson’s TV-worthy conclusion, he found that tweets from an Android phone (probably from Trump himshelf) are more negative than tweets from an iPhone (probably from his campaign). We can refomulate this into a research question: are tweets from Donald Trump’s twitter account tweeted using an iPhone more positive than those tweeted using an Android phone? There are many elements to unpack from the above paragraph, but the above paragraph illustrates how data scientists and automated content analysis practitioners approach the problem differently. The utmost important element is: All automated content analysis project must have hypotheses to test or research questions to answer. If a project without hypotheses or research questions, it can hardly be called automated content analysis (see Chapter 2 for longer discussion). We also need to specify the context we are interested in analyzing (Donald Trump and his Twitter). Later on, we need to think about the operationalization of variables (what is positive?), data collection plan and data analysis strategy. In this book, however, we are not going to focus on 1) how to form hypotheses or research questions and 2) how to collect your (text) data. The reason for excluding the former is simple: It needs to be supported by communication theories. As a book that is intented as an research methods book, it is probably a bit too much to ask.2 For the latter, the exclusion of it is due to the fact that there are good papers and textbooks available. The book chapter by Liang and Zhu (2017) is probably a good start. Munzert et al. (2014) ’s Automated Data Collection with R is an in-depth manual. At this point, you should probably go to preregister the hypotheses of this automated content analysis project. And then you should study the rtweet package by the wonderful Michael Kearney. Let’s suppose your data is now magically available. In the companion website of this book, you can find the data file with tweets from Donald Trump’s tweet account before he assumes duty as the president of the United States (2015-Jan to 2016-Dec). We need to select this time range because Donald Trump’s account did not tweet anymore using an Android phone after March, 2017. The data looks like this: require(tidyverse) require(quanteda) require(rio) require(lubridate) trump_tweets &lt;- import(&#39;./data/trump.json&#39;) %&gt;% as_tibble %&gt;% mutate(created_at = parse_date_time(created_at, orders = &#39;%a %b %d %H:%M:%S %z %Y&#39;)) %&gt;% filter(created_at &gt;= ymd_hms(&#39;2015-01-01 00:00:00&#39;) &amp; created_at &lt;= ymd_hms(&#39;2016-12-31 23:59:59&#39;)) trump_tweets ## # A tibble: 11,761 x 7 ## source text created_at retweet_count favorite_count is_retweet ## &lt;chr&gt; &lt;chr&gt; &lt;dttm&gt; &lt;int&gt; &lt;int&gt; &lt;lgl&gt; ## 1 Twitt… &quot;RT … 2016-12-31 18:59:04 9529 0 TRUE ## 2 Twitt… &quot;Hap… 2016-12-31 18:58:12 9529 55601 FALSE ## 3 Twitt… &quot;Hap… 2016-12-31 13:17:21 141853 350860 FALSE ## 4 Twitt… &quot;Rus… 2016-12-30 22:18:18 23213 84254 FALSE ## 5 Twitt… &quot;Joi… 2016-12-30 19:46:55 7366 25336 FALSE ## 6 Twitt… &quot;Gre… 2016-12-30 19:41:33 34415 97669 FALSE ## 7 Twitt… &quot;My … 2016-12-29 14:54:21 11330 45609 FALSE ## 8 Twitt… &quot;&#39;Ec… 2016-12-28 22:06:28 13919 51857 FALSE ## 9 Twitt… &quot;not… 2016-12-28 14:25:11 34542 117710 FALSE ## 10 Twitt… &quot;We … 2016-12-28 14:19:46 30237 106626 FALSE ## # … with 11,751 more rows, and 1 more variable: id_str &lt;chr&gt; Up to this point, you might notice this book uses tidyverse—or more precisely, dplyr—for data manipulation. Yes. If you are not familar with dplyr, it is a good idea for you to read the book R4DS (available online). The book you are reading now is not an introduction to dplyr. But as a refresher, let me show you all the dplyr you will need to deal with 80% of the situations. You probably only need to know 5 verbs and then combine them together. You may call these 6 verbs “Big Six” if you like. 3.2 An express summary of tidyverse The first verb is select. It is used to select particular column(s) from a data frame. By the way, our data is a tibble, an arguably nicer version of data frame. Suppose we want to select only the columns source and text. trump_tweets %&gt;% select(source, text) ## # A tibble: 11,761 x 2 ## source text ## &lt;chr&gt; &lt;chr&gt; ## 1 Twitter for iPh… &quot;RT @realDonaldTrump: Happy Birthday @DonaldJTrumpJr!\\nhttp… ## 2 Twitter for iPh… &quot;Happy Birthday @DonaldJTrumpJr!\\nhttps://t.co/uRxyCD3hBz&quot; ## 3 Twitter for And… &quot;Happy New Year to all, including to my many enemies and th… ## 4 Twitter for And… &quot;Russians are playing @CNN and @NBCNews for such fools - fu… ## 5 Twitter for iPh… &quot;Join @AmerIcan32, founded by Hall of Fame legend @JimBrown… ## 6 Twitter for And… &quot;Great move on delay (by V. Putin) - I always knew he was v… ## 7 Twitter for iPh… &quot;My Administration will follow two simple rules: https://t.… ## 8 Twitter for iPh… &quot;&#39;Economists say Trump delivered hope&#39; https://t.co/SjGBggl… ## 9 Twitter for And… &quot;not anymore. The beginning of the end was the horrible Ira… ## 10 Twitter for And… &quot;We cannot continue to let Israel be treated with such tota… ## # … with 11,751 more rows The second verb is filter. It is used to filter rows from a tibble based on certain criteria. Suppose you want to get all the rows which were tweeted from an Android phone. trump_tweets %&gt;% filter(str_detect(source, &quot;Android&quot;)) %&gt;% select(source, text) ## # A tibble: 7,015 x 2 ## source text ## &lt;chr&gt; &lt;chr&gt; ## 1 Twitter for And… Happy New Year to all, including to my many enemies and tho… ## 2 Twitter for And… Russians are playing @CNN and @NBCNews for such fools - fun… ## 3 Twitter for And… Great move on delay (by V. Putin) - I always knew he was ve… ## 4 Twitter for And… not anymore. The beginning of the end was the horrible Iran… ## 5 Twitter for And… We cannot continue to let Israel be treated with such total… ## 6 Twitter for And… Doing my best to disregard the many inflammatory President … ## 7 Twitter for And… The U.S. Consumer Confidence Index for December surged near… ## 8 Twitter for And… President Obama campaigned hard (and personally) in the ver… ## 9 Twitter for And… The DJT Foundation, unlike most foundations, never paid fee… ## 10 Twitter for And… I gave millions of dollars to DJT Foundation, raised or rec… ## # … with 7,005 more rows In the above example, we combine two verbs (filter and select) using the pipe (%&gt;%) operator. Some might disagree, but this method is more elegant. If you can tell a story using your dplyr code, it is probably a good code. For example, you can tell a story using the above code as such: We have our trump_tweets data, and then we filter all tweets where source contains “Android”, and then we select only the source and text columns. So, the pipe operators in the above code are corresponding to all “and then” in the story. From the above story, you might notice that the source column is recording from which device the tweet was tweeted, e.g. Android. It is a good idea to see what are the other variants of “source” in our data. The next verb that we need to know is group_by. trump_tweets %&gt;% group_by(source) ## # A tibble: 11,761 x 7 ## # Groups: source [15] ## source text created_at retweet_count favorite_count is_retweet ## &lt;chr&gt; &lt;chr&gt; &lt;dttm&gt; &lt;int&gt; &lt;int&gt; &lt;lgl&gt; ## 1 Twitt… &quot;RT … 2016-12-31 18:59:04 9529 0 TRUE ## 2 Twitt… &quot;Hap… 2016-12-31 18:58:12 9529 55601 FALSE ## 3 Twitt… &quot;Hap… 2016-12-31 13:17:21 141853 350860 FALSE ## 4 Twitt… &quot;Rus… 2016-12-30 22:18:18 23213 84254 FALSE ## 5 Twitt… &quot;Joi… 2016-12-30 19:46:55 7366 25336 FALSE ## 6 Twitt… &quot;Gre… 2016-12-30 19:41:33 34415 97669 FALSE ## 7 Twitt… &quot;My … 2016-12-29 14:54:21 11330 45609 FALSE ## 8 Twitt… &quot;&#39;Ec… 2016-12-28 22:06:28 13919 51857 FALSE ## 9 Twitt… &quot;not… 2016-12-28 14:25:11 34542 117710 FALSE ## 10 Twitt… &quot;We … 2016-12-28 14:19:46 30237 106626 FALSE ## # … with 11,751 more rows, and 1 more variable: id_str &lt;chr&gt; It seems that we have done nothing here. But you might notice the output says “Groups: source [16]”. group_by works the best when it is combined with summarise. dplyr is smart enough to accept both British and American spellings. So you can use summarize if you want.3 We use summarise to generate one-element summary of your data. For example, you want to get the total number of rows of this data. trump_tweets %&gt;% summarise(ntweets = n()) ## # A tibble: 1 x 1 ## ntweets ## &lt;int&gt; ## 1 11761 Using the above code, we can tell a story as such: We have our trump_tweets data, and then we want to summarise our data as ntweets whereas ntweets equals to n(), i.e. number of rows. Let’s try to use this verb with group_by: trump_tweets %&gt;% group_by(source) %&gt;% summarise(ntweets = n()) ## # A tibble: 15 x 2 ## source ntweets ## &lt;chr&gt; &lt;int&gt; ## 1 Facebook 2 ## 2 Instagram 70 ## 3 Media Studio 1 ## 4 Mobile Web (M5) 2 ## 5 Neatly For BlackBerry 10 5 ## 6 Periscope 7 ## 7 TweetDeck 2 ## 8 Twitter Ads 64 ## 9 Twitter for Android 7015 ## 10 Twitter for BlackBerry 94 ## 11 Twitter for iPad 22 ## 12 Twitter for iPhone 2369 ## 13 Twitter Mirror for iPad 1 ## 14 Twitter QandA 10 ## 15 Twitter Web Client 2097 The story of the above code is: We have our trump_tweets … probably I can skip this part now, and then we group our data by source and then we summarise our data as ntweets whereas ntweets equals to n(), i.e. number of rows. So, what group_by does, is to split the data into groups by a certain column (or columns). The subsequent steps are then became group-based analysis. This principle is called “Split-Apply-Combine strategy” by Wickham (2011). this group-based analysis shows that there are many variants! In this analysis, we keep only those tweets from iPhone and Android only. So, which verb we should use? I give you 10 seconds to think. Well… trump_tweets %&gt;% filter(str_detect(source, &quot;Android|iPhone&quot;)) ## # A tibble: 9,384 x 7 ## source text created_at retweet_count favorite_count is_retweet ## &lt;chr&gt; &lt;chr&gt; &lt;dttm&gt; &lt;int&gt; &lt;int&gt; &lt;lgl&gt; ## 1 Twitt… &quot;RT … 2016-12-31 18:59:04 9529 0 TRUE ## 2 Twitt… &quot;Hap… 2016-12-31 18:58:12 9529 55601 FALSE ## 3 Twitt… &quot;Hap… 2016-12-31 13:17:21 141853 350860 FALSE ## 4 Twitt… &quot;Rus… 2016-12-30 22:18:18 23213 84254 FALSE ## 5 Twitt… &quot;Joi… 2016-12-30 19:46:55 7366 25336 FALSE ## 6 Twitt… &quot;Gre… 2016-12-30 19:41:33 34415 97669 FALSE ## 7 Twitt… &quot;My … 2016-12-29 14:54:21 11330 45609 FALSE ## 8 Twitt… &quot;&#39;Ec… 2016-12-28 22:06:28 13919 51857 FALSE ## 9 Twitt… &quot;not… 2016-12-28 14:25:11 34542 117710 FALSE ## 10 Twitt… &quot;We … 2016-12-28 14:19:46 30237 106626 FALSE ## # … with 9,374 more rows, and 1 more variable: id_str &lt;chr&gt; mutate is for creating new columns. trump_tweets %&gt;% filter(str_detect(source, &quot;Android|iPhone&quot;)) %&gt;% mutate(android = str_detect(source, &quot;Android&quot;)) %&gt;% select(android, text) ## # A tibble: 9,384 x 2 ## android text ## &lt;lgl&gt; &lt;chr&gt; ## 1 FALSE &quot;RT @realDonaldTrump: Happy Birthday @DonaldJTrumpJr!\\nhttps://t.co/… ## 2 FALSE &quot;Happy Birthday @DonaldJTrumpJr!\\nhttps://t.co/uRxyCD3hBz&quot; ## 3 TRUE &quot;Happy New Year to all, including to my many enemies and those who h… ## 4 TRUE &quot;Russians are playing @CNN and @NBCNews for such fools - funny to wa… ## 5 FALSE &quot;Join @AmerIcan32, founded by Hall of Fame legend @JimBrownNFL32 on … ## 6 TRUE &quot;Great move on delay (by V. Putin) - I always knew he was very smart… ## 7 FALSE &quot;My Administration will follow two simple rules: https://t.co/ZWk0j4… ## 8 FALSE &quot;&#39;Economists say Trump delivered hope&#39; https://t.co/SjGBgglIuQ&quot; ## 9 TRUE &quot;not anymore. The beginning of the end was the horrible Iran deal, a… ## 10 TRUE &quot;We cannot continue to let Israel be treated with such total disdain… ## # … with 9,374 more rows Last but not least, arrange is for sorting. trump_tweets %&gt;% filter(str_detect(source, &quot;Android|iPhone&quot;)) %&gt;% mutate(android = str_detect(source, &quot;Android&quot;)) %&gt;% select(android, text) %&gt;% arrange(android) ## # A tibble: 9,384 x 2 ## android text ## &lt;lgl&gt; &lt;chr&gt; ## 1 FALSE &quot;RT @realDonaldTrump: Happy Birthday @DonaldJTrumpJr!\\nhttps://t.co/… ## 2 FALSE &quot;Happy Birthday @DonaldJTrumpJr!\\nhttps://t.co/uRxyCD3hBz&quot; ## 3 FALSE &quot;Join @AmerIcan32, founded by Hall of Fame legend @JimBrownNFL32 on … ## 4 FALSE &quot;My Administration will follow two simple rules: https://t.co/ZWk0j4… ## 5 FALSE &quot;&#39;Economists say Trump delivered hope&#39; https://t.co/SjGBgglIuQ&quot; ## 6 FALSE &quot;The world was gloomy before I won - there was no hope. Now the mark… ## 7 FALSE &quot;#MerryChristmas https://t.co/5GgDmJrGMS&quot; ## 8 FALSE &quot;Happy #Hanukkah https://t.co/UvZwtykV1E&quot; ## 9 FALSE &quot;As to the U.N., things will be different after Jan. 20th.&quot; ## 10 FALSE &quot;The resolution being considered at the United Nations Security Coun… ## # … with 9,374 more rows It seems that it did nothing. We can set it to arrange by descending order. So that the tweets from Android are on top. trump_tweets %&gt;% filter(str_detect(source, &quot;Android|iPhone&quot;)) %&gt;% mutate(android = str_detect(source, &quot;Android&quot;)) %&gt;% select(android, text) %&gt;% arrange(desc(android)) ## # A tibble: 9,384 x 2 ## android text ## &lt;lgl&gt; &lt;chr&gt; ## 1 TRUE Happy New Year to all, including to my many enemies and those who ha… ## 2 TRUE Russians are playing @CNN and @NBCNews for such fools - funny to wat… ## 3 TRUE Great move on delay (by V. Putin) - I always knew he was very smart! ## 4 TRUE not anymore. The beginning of the end was the horrible Iran deal, an… ## 5 TRUE We cannot continue to let Israel be treated with such total disdain … ## 6 TRUE Doing my best to disregard the many inflammatory President O stateme… ## 7 TRUE The U.S. Consumer Confidence Index for December surged nearly four p… ## 8 TRUE President Obama campaigned hard (and personally) in the very importa… ## 9 TRUE The DJT Foundation, unlike most foundations, never paid fees, rent, … ## 10 TRUE I gave millions of dollars to DJT Foundation, raised or recieved mil… ## # … with 9,374 more rows Oh, yea! We have our data! So we should do our sentiment analysis now, right? NO! Nein! Non! いいえ! 唔係! 3.3 Creating ground truth data This is another split-path between data scientists and automated content analysts. If you know nothing about automated content analysis, the traditional way of dealing with our data is to manually code all tweets. The word “code” as a verb can create confusion here, because it can also mean “programming.”4 In this programming-heavy book, I am going to use another verb for “coding” (in the social sciences’ sense): data categorizing. I believe this term can still capture most, but not all, nuances of the verb “coding” (in the social sciences’ sense). For the verb “coding” in the programming’s sense, I am going to use, as you can guess, programming. Sorry for the detour. Traditionally, social scientists approach this problem by catagorizing the unstructured data into a form suitable for computer analysis. A tweet is a bunch of characters that a (naive) computer cannot extract meanings—or semantics—out of it. However, whether or not a tweet is positive is a semantic problem. Homo sapiens have a brain and some of us have the knowledge in English to determine the semantics of a piece of text. We need to tell the computer, what semantically is expressed in a tweet. This procedure is called data categorization. In an academic setting, it usually means the principal investigator of this project (i.e. you) would assemble a team of student assistants to categorize all tweets by reading them one by one and then asserting every one of them if they are positive or not. In order to ensure interrater reliability, we usually assign at least two student assistants to read one tweet. This procedure of data categorization is notoriously expensive. In Germany, for instance, one needs to pay a student assistant €15.8 per hour in 2020. Let’s assume a student assistant can read 4 tweets per minute. In order to read every single tweets (n = 15,267) by two students, it takes (15,267 x 2) / 4 = 7,633.5 man-minutes or 127.2 man-hours. Therefore, the principal investigator (i.e you) needs to pay €2009.76 just for the data categorization. It is not a handsome amount of money: You can buy 4464 packs of instant ramen that you can eat for about a year. But remember, now you are not doing this for your PhD thesis. It is just an exercise of a stupid book. If you are willing to pay this: “Danke schön!”, your student assistants say. If you are not willing to pay this, what should you do? Instead of asking your student assistants to categorize all data, we can use a computer to categorize the data. But as I said previously, a (naive) computer cannot extract semantics from a piece of text. However, it can extract an approximated version of semantics —or a surrogate measure— from text content. So, what is a surrogate surrogate? The dictionary by Upton and Cook (2014) gives this definition: “A variable that can be measured (or is easy to measure) that is used in place of one that cannot be measured (or is difficult to measure)”. A very similar term is “proxy measure” but there is one crucial difference: Proxy measure is a variable that is used in place of one that cannot be measure. Period. There is no “or” after it. As indicated previously, we can measure the negativity or a tweet by manual data categorization, it is just “diffuclt to measure” due to the cost. Thus, we use a surrogate measure instead. A good surrogate measure should have a strong correlation with the original variable. For example, it is difficult to assess the wealth of a family. It is just difficult, not impossible. As a surrogate measure, we can use the value of the family’s house as an approximation. We know that in normal circumstances, the two variables (the wealth of the family and the value of the family’s house) should be correlated. But for this correlation to be valid, there are many assumptions: people can actually afford a house, rich people buy expensive houses and the housing market is not regulated, just to name three. A surrogate measure is good only when the domain of the measurement can hold the assumptions that maintain the correlation between the surrogate measure and the actual measure. We will come back to this point in Chapter 4. We —as a practitioner of automated content analysis— cannot blindly accept a surrogate measure is always good. It is related to the fact that we are doing automated content analysis, which is actually a content analysis. In the next chapter, we will come back to the validity requirement of any content analysis, automated or not. Up to this point, we have a dilemma: Manual data categorization is too expensive but automated content analysis is just a surrogate measure. What should we do? A simple solution is to test whether the domain of our measurement fits the original assumptions. Therefore, we need to test the correlation between the approximated semantics extracted by the computer and the semantics extracted by humans. As said before, a good surrogate measure should have a strong correlation with the original measurement. For this, we do not need to manually categorize a lot of tweets. A randomly selected handful of tweets will do. We have a name for these manually categorized data for testing the validity of a tool: ground truth data. We will talk more on how to create ground truth data in Chapter 4. As an excercise of creating ground truth data, let’s say we want to create a set of ground truth data with a random sample of 30 tweets. It can be done easily with: set.seed(42) trump_tweets %&gt;% sample_n(30) %&gt;% select(text) %&gt;% rio::export(&#39;data/trump_tweet30.rds&#39;) And then, I ask my team of two student assistants to manually categorize these 30 tweets. This task should take (30 x 2) / 4 = 15 man-minutes. The cost of it (€3.95) is only a few packs of instant ramen. Or, if you are middle class and don’t mind damaging the environment, it is the cost of a “coffee to go”. The coding procedure is simple, or even simplified. The two student assistants categorize the 30 tweets into a category of whether or not the tweet is negative with a 5-point likert scale, i.e. Wow, I have had so many calls from high ranking people laughing at the stupidity of the failing @nytimes piece. Massive front page for that! How negative is the above tweet? 1.Very negative 2.Negative 3.Neutral 4.Positive 5.Very positive And the data looks like this: trump_tweet30_coded &lt;- rio::import(&quot;data/trump_tweet30_coded.rds&quot;) trump_tweet30_coded ## # A tibble: 30 x 3 ## text rater1 rater2 ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 &quot;\\&quot;@RealityTVBliss: If I was ever on #CelebrityApprentice, the… 3 3 ## 2 &quot;Wow, I have had so many calls from high ranking people laughi… 2 2 ## 3 &quot;\\&quot;@pjs307: @WalshFreedom Will be highest rated show ever, @re… 4 4 ## 4 &quot;\\&quot;@BizMotivationTV: Go to work, be smart, think positively an… 4 4 ## 5 &quot;\\&quot;@Jimbos2002: @Morning_Joe Video: Hillary referring to blac… 2 2 ## 6 &quot;\\&quot;@DavidNYCT: @realDonaldTrump We will!\\&quot;&quot; 3 3 ## 7 &quot;\\&quot;@OscarBagPledge: Congrats @LeezaGibbons @ApprenticeNBC @rea… 3 4 ## 8 &quot;Thank you Maine, New Hampshire and Iowa. The waiting is OVER!… 4 4 ## 9 &quot;Via @trscoop: “Mark Levin DEFENDS Trump: Hillary Clinton is a… 1 1 ## 10 &quot;National Review is a failing publication that has lost it&#39;s w… 1 2 ## # … with 20 more rows We consider the two columns of coder1 and coder2 our ground truth data. In the next section, we will use these ground truth data to validate the automatically extracted semantics from Trump’s tweets. 3.4 Automated sentiment analysis: AFINN Now, with the ground truth data, we can finally do the so called ‘sentiment analysis’. Before, we really do it, I would like to remind you for one last time that the semantics extracted by these method are an approximated version of the true semantics. Thus, it is a surrogate at best. The simpliest method for doing a sentiment analysis is using a dictionary-based method. These methods are explained in Chapter 6. In short, these methods rely on two simple assumptions to calculate the overall sentiment of a piece of text. A dictionary is a collection of words. For example, a negative dictionary might have words that contain negative meanings, for example, f… fool, f… foolish, or f… faulty. A positive dictionary might have words such as good, nice, wonderful. A piece of text with a lot of words in the negative dictionary should have a higher negativity. There are many of these dictionaries available. These readily available dictionaries are called off-the-shelf dictionaries. In Chapter 6, we will discuss the problems of using them. But one way to avoid those problems is to first create ground truth data and validate these dictionaries before use. Another way to avoid those problems is a to use a theory-informed dictionary. We will also talk about how to choose a dictionary in Chapter 6. Here, we are going to use the AFINN dictionary (Nielsen 2011). It is a dictionary designed for measuring sentiment of microblog data, e.g. tweets. afinn &lt;- readRDS(&quot;data/afinn.RDS&quot;) afinn ## Dictionary object with 11 key entries. ## - [neg5]: ## - bastard, bastards, bitch, bitches, cock, cocksucker, cocksuckers, cunt, motherfucker, motherfucking, niggas, nigger, prick, slut, son-of-a-bitch, twat ## - [neg4]: ## - ass, assfucking, asshole, bullshit, catastrophic, damn, damned, damnit, dick, dickhead, fraud, frauds, fraudster, fraudsters, fraudulence, fraudulent, fuck, fucked, fucker, fuckers [ ... and 23 more ] ## - [neg3]: ## - abhor, abhorred, abhorrent, abhors, abuse, abused, abuses, abusive, acrimonious, agonise, agonised, agonises, agonising, agonize, agonized, agonizes, agonizing, anger, angers, angry [ ... and 244 more ] ## - [neg2]: ## - abandon, abandoned, abandons, abducted, abduction, abductions, accident, accidental, accidentally, accidents, accusation, accusations, accuse, accused, accuses, accusing, ache, aching, admonish, admonished [ ... and 945 more ] ## - [neg1]: ## - absentee, absentees, admit, admits, admitted, affected, afflicted, affronted, alas, alert, ambivalent, anti, apologise, apologised, apologises, apologising, apologize, apologized, apologizes, apologizing [ ... and 289 more ] ## - [zero]: ## - some kind ## [ reached max_nkey ... 5 more keys ] Sorry for the strong language. AFINN contains categories of words sorted by valence values from -5 (neg5) to +5 (pos5). For example, the word ‘bastard’ is -5 in terms of valence value. According to original paper of AFINN (Nielsen 2011), the AFINN sentiment score of a tweet is calculated as the total valence values of matching words divided by the total number of words. For example, the AFINN sentiment score of the tweet “He is a bastard” is -5 / 4 = 1.25. The total valence values of matching words is 5 because there is only one matching word (bastard) and its valence value is -5. In total, this tweet has 4 words. The following program calculates the correponding AFINN score of each tweet using the R package quanteda (Benoit et al. 2018). In short, this program creates a document-feature matrix (DFM) using Trump’s tweets and then look up this DFM by the AFINN dictionary to seek for matching words. And then, we convert this DFM into a data frame and then do our dplyr magic to calculate the AFINN sentiment score. It might look a bit scary and don’t worry, we will walk through this program again step-by-step in Chapter 6. dfm(trump_tweet30_coded$text, remove_punct = TRUE) %&gt;% dfm_lookup(afinn) %&gt;% quanteda::convert(to = &quot;data.frame&quot;) %&gt;% mutate(matching_word_valence = (neg5 * -5) + (neg4 * -4) + (neg3 * -3) + (neg2 * -2) + (neg1 * -1) + (zero * 0) + (pos1 * 1) + (pos2 * 2) + (pos3 * 3) + (pos4 * 4) + (pos5 * 5), base = ntoken(trump_tweet30_coded$text, remove_punct = TRUE), afinn_score = matching_word_valence / base) %&gt;% pull(afinn_score) -&gt; afinn_score afinn_score ## text1 text2 text3 text4 text5 text6 ## 0.05000000 0.12000000 0.11111111 0.58333333 0.16666667 0.00000000 ## text7 text8 text9 text10 text11 text12 ## 0.16666667 0.09090909 -0.19047619 -0.26923077 0.00000000 -0.13333333 ## text13 text14 text15 text16 text17 text18 ## 0.00000000 0.00000000 -0.13636364 0.00000000 0.47619048 0.22222222 ## text19 text20 text21 text22 text23 text24 ## 0.14285714 0.77777778 0.00000000 -0.04761905 -0.06666667 0.53333333 ## text25 text26 text27 text28 text29 text30 ## 0.16666667 0.00000000 0.00000000 0.69230769 0.18750000 0.25000000 Once again, this AFINN sentiment score is a surrogate measure of semantics. We can test the correlation between the AFINN score and the results from two human coders. cor.test(trump_tweet30_coded$rater1, afinn_score) ## ## Pearson&#39;s product-moment correlation ## ## data: trump_tweet30_coded$rater1 and afinn_score ## t = 3.6976, df = 28, p-value = 0.0009395 ## alternative hypothesis: true correlation is not equal to 0 ## 95 percent confidence interval: ## 0.2677772 0.7734500 ## sample estimates: ## cor ## 0.5727884 cor.test(trump_tweet30_coded$rater2, afinn_score) ## ## Pearson&#39;s product-moment correlation ## ## data: trump_tweet30_coded$rater2 and afinn_score ## t = 2.669, df = 28, p-value = 0.01251 ## alternative hypothesis: true correlation is not equal to 0 ## 95 percent confidence interval: ## 0.1075218 0.6974559 ## sample estimates: ## cor ## 0.450346 The two correlation coefficients are statistically sigificant. The scatterplot of the two measures is like so: trump_tweet30_coded %&gt;% mutate(afinn_score = afinn_score) %&gt;% mutate(avg_human = (rater1 + rater2) / 2) %&gt;% ggplot(aes(x = avg_human, y = afinn_score)) + geom_point() + geom_smooth(method = &quot;lm&quot;) (#fig:corafinn_human)Scatterplot of the correlation between human categorization and AFINN score. It seems that we have evidence to show the AFINN score is a good surrogate measure of sentiment because it has a good correlation with human judgements. Only after this step, we can apply the method to all of the tweets. 3.5 Comparing tweets from Android and iPhone So, we have shown in the previous sections that AFINN score is a good surrogate measure of sentiment. Now, we can calculate the AFINN score of all tweets. trump_tweets %&gt;% filter(str_detect(source, &quot;Android|iPhone&quot;)) %&gt;% mutate(android = str_detect(source, &quot;Android&quot;)) %&gt;% select(android, text) -&gt; trump_tweets_target trump_tweets_target ## # A tibble: 9,384 x 2 ## android text ## &lt;lgl&gt; &lt;chr&gt; ## 1 FALSE &quot;RT @realDonaldTrump: Happy Birthday @DonaldJTrumpJr!\\nhttps://t.co/… ## 2 FALSE &quot;Happy Birthday @DonaldJTrumpJr!\\nhttps://t.co/uRxyCD3hBz&quot; ## 3 TRUE &quot;Happy New Year to all, including to my many enemies and those who h… ## 4 TRUE &quot;Russians are playing @CNN and @NBCNews for such fools - funny to wa… ## 5 FALSE &quot;Join @AmerIcan32, founded by Hall of Fame legend @JimBrownNFL32 on … ## 6 TRUE &quot;Great move on delay (by V. Putin) - I always knew he was very smart… ## 7 FALSE &quot;My Administration will follow two simple rules: https://t.co/ZWk0j4… ## 8 FALSE &quot;&#39;Economists say Trump delivered hope&#39; https://t.co/SjGBgglIuQ&quot; ## 9 TRUE &quot;not anymore. The beginning of the end was the horrible Iran deal, a… ## 10 TRUE &quot;We cannot continue to let Israel be treated with such total disdain… ## # … with 9,374 more rows Once again, we use quanteda to calculate the AFINN score. The program below is actually the same as the one above. dfm(trump_tweets_target$text, remove_punct = TRUE) %&gt;% dfm_lookup(afinn) %&gt;% quanteda::convert(to = &quot;data.frame&quot;) %&gt;% mutate(matching_word_valence = (neg5 * -5) + (neg4 * -4) + (neg3 * -3) + (neg2 * -2) + (neg1 * -1) + (zero * 0) + (pos1 * 1) + (pos2 * 2) + (pos3 * 3) + (pos4 * 4) + (pos5 * 5), base = ntoken(trump_tweets_target$text, remove_punct = TRUE), afinn_score = matching_word_valence / base) %&gt;% pull(afinn_score) -&gt; all_afinn_score So now, we have the information about the device and the AFINN score. tibble(afinn = all_afinn_score, android = trump_tweets_target$android, trump_tweets_target$text) ## # A tibble: 9,384 x 3 ## afinn android `trump_tweets_target$text` ## &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt; ## 1 0.5 FALSE &quot;RT @realDonaldTrump: Happy Birthday @DonaldJTrumpJr!\\nhttps… ## 2 0.75 FALSE &quot;Happy Birthday @DonaldJTrumpJr!\\nhttps://t.co/uRxyCD3hBz&quot; ## 3 -0.0714 TRUE &quot;Happy New Year to all, including to my many enemies and tho… ## 4 0.0952 TRUE &quot;Russians are playing @CNN and @NBCNews for such fools - fun… ## 5 0.118 FALSE &quot;Join @AmerIcan32, founded by Hall of Fame legend @JimBrownN… ## 6 0.214 TRUE &quot;Great move on delay (by V. Putin) - I always knew he was ve… ## 7 0 FALSE &quot;My Administration will follow two simple rules: https://t.c… ## 8 0.333 FALSE &quot;&#39;Economists say Trump delivered hope&#39; https://t.co/SjGBgglI… ## 9 -0.0417 TRUE &quot;not anymore. The beginning of the end was the horrible Iran… ## 10 -0.04 TRUE &quot;We cannot continue to let Israel be treated with such total… ## # … with 9,374 more rows We can see the mean AFINN scores of tweets from Android and iPhone. tibble(afinn = all_afinn_score, android = trump_tweets_target$android) %&gt;% group_by(android) %&gt;% summarise(mean_afinn = mean(afinn), se = sd(afinn) / sqrt(n()), lower = mean_afinn - (1.96 * se), upper = mean_afinn + (1.96 * se)) %&gt;% mutate(phone = ifelse(android, &quot;Android&quot;, &quot;iPhone&quot;)) %&gt;% select(-se, -android) ## # A tibble: 2 x 4 ## mean_afinn lower upper phone ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 0.126 0.117 0.136 iPhone ## 2 0.101 0.0963 0.106 Android Tweets from Android are having a slightly lower sentiment score (more negative) than those from iPhone. We can also conduct a test to study the statistical significance of the difference. tibble(afinn = all_afinn_score, android = trump_tweets_target$android) %&gt;% wilcox.test(afinn ~ android, data = .) ## ## Wilcoxon rank sum test with continuity correction ## ## data: afinn by android ## W = 8879860, p-value = 4.651e-07 ## alternative hypothesis: true location shift is not equal to 0 It is statistically significant. You can see the distributions of AFINN scores of tweets from an Android and an iPhone with the following histogram. tibble(afinn = all_afinn_score, android = trump_tweets_target$android) %&gt;% ggplot(aes(x = afinn, fill = android)) + geom_histogram(binwidth = 0.05, alpha = 0.5) In summary, Trump’s tweets from an Android phone are more negative than those from an iPhone. We have arrived at a very similar conclusion to Robinson’s, although the effect size is much smaller. The obvious question you may ask is: Why could Robinson get such a large effect size? A more important question: Whom should you trust? In Chapter 6, we will have a more detailed discussion about the pros and cons of using dictionary-based methods. Regarding the question of “whom should you trust?”, our approach has face validity and criterion validity. For face validity, We have used a dictionary designed for studying social media data (AFINN), whereas David Robinson used NRC dictionaries which are not designed for studying social media data. For criterion validity, we have validated our AFINN scores with some human-categorized tweets. We have evidence that our AFINN scores correlate well with human judgements of sentiment. David Robinson had no such information. There are some information which is important. Dictionary-based methods are very sensitive to content length. One thing you need to know is that Trump’s tweets from an android are in general longer than tweets from an iPhone. Also, these tweets are in general more negative. tibble(afinn = all_afinn_score, android = trump_tweets_target$android, text = trump_tweets_target$text, ntokens = ntoken(text, remove_punct = TRUE)) %&gt;% group_by(android) %&gt;% summarise(mean_ntokens = mean(ntokens), mean_afinn = mean(afinn)) ## # A tibble: 2 x 3 ## android mean_ntokens mean_afinn ## &lt;lgl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 FALSE 14.7 0.126 ## 2 TRUE 17.6 0.101 We can demonstrate it using a scatterplot. tibble(afinn = all_afinn_score, android = trump_tweets_target$android, text = trump_tweets_target$text, ntokens = ntoken(text, remove_punct = TRUE)) %&gt;% ggplot(aes(y = afinn, x = ntokens, col = android)) + geom_point() + geom_smooth(method = &quot;loess&quot;) In Chapter 6, I will demonstrate further why we always need to check for the influence of content length. In our AFINN score calculation, we have adjusted for the effect of content length. However, our AFINN score is still correlated with content length with a correlation coefficient of -0.25. OK, enough. This is not a diss track. Let’s move on and go to the summary of this chapter, shall we? 3.6 Zusammenfassung In this chapter, I have used a “whole game” to demonstrate the differences between automated content analysis and other approaches. It can be summarized into a few bullet points: Automated content analysis always starts with research questions or hypotheses. Automated content analysis is a content analysis, therefore, we need to demonstrate the validity and reliability of our measurement. Automated content analysis is usually a cost-cutting measure because manual content analysis is very expensive when n is getting larger. We can extract semantics from a piece of text using automated methods. But we must bear in mind that these extracted semantics are surrogate —Not always true—. Because we have the bullet point 2 above, we need to show that the surrogate measure is a good approximation of human judgement. There are many problems associated with automated extraction of semantics from a piece of text. I hope this chapter is a eye-opener for you and you want to dig deeper into the world of automated content analysis. In the next chapter, we are going to define (automated) content analysis and establish some best practices. References "],
["what-is-content-analysis.html", "Chapter 4 What is Content analysis 4.1 What gets automated? 4.2 Best practices", " Chapter 4 What is Content analysis In the previous chapter, we have gone through together in a whole game approach a typical scenario of automated content analysis. In this chapter, we are going to go back to the theorectical foundation of automated content analysis. Unless the adjective before an objective functions is a negation, one should expect an object with an adjective should still belong to the category of that object. For example, a flying cat is still a cat. A liberal, popular, male dictator is still a dictator. However, fake news is not news, because ‘fake’ functions as a negation. Based on this logic, in the previous chapter I have made a proclaimation that automated content analysis is still content analysis. It is similar to the fact that quantative content analysis is still content analysis. This seems to be a reasonable expectation, but one cannot always assume these long compound nouns created by researchers always have this simple, logical property. For example, thematic meta-analysis is not meta-analysis, eventhough ‘thematic’ does not function as a negation.5 So, what is automated content analysis all about? It is better for us to go back to the basic form: What is content analysis? 4.0.1 Definitions In the realm of content analysis, there are two bibles, so to speak. They are “Content Analysis: An Introduction to Its Methodology” by Klaus Krippendorff and “The Content Analysis Guidebook” by Kimberley A. Neuendorf. Except the fact that both books are written by communication researcher, both books give a very similar definition of content analysis. Krippendorff defines content analysis as follow: Content analysis is a research technique for making replicable and valid inferences from text (or other meaningful matter) to the context of their use. Neuendorf defines content analysis as follow: Content analysis is a summarizing, quantitative analysis of messages that relies on the scientific method (including attention to objectivity-intersubjectivity, a priori design, reliability, validity, generalizability, replicability, and hypothesis testing) and is not limited as to the types of variables that may be measured or the context in which the message are created or presented. Both definitions emphasize the scientific aspect of the technique. Neuendorf has a six-part definition of content analysis as a scientific method, which explains each of the six elements inside the parenthesis of her definition. Once again, all six elements define how content analysis is a scientific method. In this discussion, I focus only on four important elements: a priori design, hypothesis testing, reliability and validity. These four elements are important for our discussion of automated content analysis and can draw distinctions between automated content analysis and other forms of text analysis, e.g. text mining. In the following two subsection, the four elements are discussed in the following two subsections: Principle and measurement. 4.0.1.1 The principle of (automated) content analysis 4.0.1.1.1 An a priori Design A content analysis should have an a priori (i.e. “before the fact”) design. Therefore, the research questions, hypotheses and operationalization of variables must be available before the text data were collected. A valid content analysis should be no room for researchers to play with the data and then choose the variables or even the hypotheses they want to study, thereby makes any content analysis be confirmatory, not exploratory. Thus, any exploratory work should not be labeled as an (automated) content analysis. This draws a major distinct between (automated) content analysis and other text analytic approaches such as text mining, “big data” or data science. Data science, as defined in Wickham and Grolemund (2016) , is a circular process of “transform” (coding / data manipulation), “visualize” (data visualization) and “model” (data modeling). This repeated circular procedure – for instance, it is possible to go back from an analytic step of data modling back to coding, is not compatible with the strict a priori requirement of (automated) content analysis. (Automated) content analysis must be a linear process. In Neuendorf’s book, she derive a flowchart of content analysis.6 In that flowchart, there is no split-path and the linear process consists of nine steps: theory and rationale, conceptualization decisions, operationalization measures, creation of coding schemes, sampling, training and initial reliability, coding, and, final reliability and tabulation and reporting. If (automated) content analysis is content analysis, it should follow the same linear process. There is only a slight difference in the assessment of reliability (next subsection). 4.0.1.1.2 Hypothesis testing A content analysis as a scientific method should be “hypothetico-deductive”. Therefore, an (automated) content analysis must have one or more theory driven hypotheses to be tested deductively. These hypotheses describe an anticipated prediction. Research question can also be derived a priori, if the existing theory is enough to support an anticipated prediction. Because of that, an (automated) content analysis must have an “a priori design” (the previous point). An exploratory analysis, such as text mining or data science approaches that finds patterns in text data, is only for hypothesis generation. 4.0.1.2 The measurement in (automated) content analysis As with all other scientific approachs, all measurements in content analysis must have an adequate level of reliability and validity. The difference between the two concepts can be explained by the oft-cited target metaphor. In this target metaphor, the target is like the one used in Archery. Or if you are from northern or western Europe, biathlon. There is a bullseye (the center of the target) which represent the actual reality. The distance between a dot (a measurement) to the bullseye represents how close the measurement is to the actual reality. Reliability is about the consistency of a measurement. A measurement with high reliability should give a very consistent value from the same physical reality under different measurement situations. Examples of these different measurement situations are measurements made by different rater (inter-rater reliability), at different time point (test-retest reliability) or even at different stages of the measurement (split-form reliability, internal consistency). In the target metaphor, a measurement with high reliability is presented as dots fall in the same small area. Validity is about how close the measurement is to the actual reality. It is usually measured by subcatgories such as contruct validity (Does the operationalization of the construct to be measured theorectically justify?), content validity (Does the content of the measurement cover all aspects of measured construct?) and criterion validity (Does the measurement correlate with other measurements that are representative of the construct?). Let’s take an example that all scholars love (and hate). If one want to measure academic success of a researcher, should one use measurements based on number of citations of this researcher’s papers (e.g. H-index)? First, this measurement can have great variability by using different citation databases (Google Scholar, Scopus, Web of Science). Thus, this measurement does not have good reliability. Regarding criterion validity, Richard Feynman has an H-index of 40. Albert Einstein is a bit better, 63. With their H-index, probably they could not even get a postdoc position nowadays. In general, reliability and validity works antagonistically. Therefore, a measurement with very high validity usually has lower reliability and vice versa. Using the above example of measuring academic success of a researcher, a measurement with greater validity is to have a panel of experts to evaluate qualitatively the researcher’s papers and their actual impact to the field. This method should have greater validity than barely using H-index, but it trades reliability for validity because the method introduces a new source of inter-rater reliability problem. 4.0.1.2.1 Reliability Traditional content analysis focuses a lot on reliability, especially inter-rater reliability. Klaus Krippendorff, the author of one of the “bibles”, even has an inter-rater reliability measurement bearing his name (Krippendorff’s \\(\\alpha\\)). This emphasis on inter-rater reliability is because of the dependency of human reading in traditional manual content analysis. Two humans can have two very different understandings of the same constructs, especially latent ones such as sentiment, liberal, populistic, or probably the most popular one, frames. Usually, researchers are advised to conduct coder training to standardize the coding among coders, an effort to improve inter-rater reliability. Using a cliche language, we train our coders to work like a computer. Computer is a determinist machine. If the algorithm does not involve any randomization, the same input always gives the same output. Therefore, inter-rater reliability is basically a non-issue for computer’s coding. There may still some reliability issues, but they manifest differently. We will discuss these issues in the next chapter. Remember reliability and validity work antagonistically? If computer’s coding can achieve very high reliability, what would be the validity of it? 4.0.1.2.2 Validity 4.1 What gets automated? What the current literature says about ACA. 4.2 Best practices Validation Contrasting Confirmatory / exploratory Methodological transparency References "],
["creating-gold-standard-validation.html", "Chapter 5 Creating gold standard &amp; validation", " Chapter 5 Creating gold standard &amp; validation avocate a workflow of making gold standard first! "],
["typical-automated-content-analytic-methods.html", "Chapter 6 Typical automated content analytic methods 6.1 dictionary-based method 6.2 topic-model", " Chapter 6 Typical automated content analytic methods 6.1 dictionary-based method how it works off-the-shelf creating domain specific one 6.1.1 validation suggestions 6.2 topic-model 6.2.1 validation daniel maier / Chang "],
["advance-topics.html", "Chapter 7 Advance topics 7.1 bag-of-embeddings 7.2 semantic network 7.3 machine learning 7.4 multimodal analysis 7.5 crosslingual analysis", " Chapter 7 Advance topics 7.1 bag-of-embeddings 7.2 semantic network 7.3 machine learning 7.4 multimodal analysis 7.5 crosslingual analysis "],
["references.html", "References", " References "]
]
